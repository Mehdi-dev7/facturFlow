# FacturFlow - Context for Claude Code

## Project Overview
SaaS de facturation intelligent avec prÃ©lÃ¨vement SEPA automatique pour freelances, auto-entrepreneurs et PME franÃ§aises. Killer feature : GoCardless pour factures rÃ©currentes sans impayÃ©s.

## Tech Stack
- **Framework**: Next.js 16 + TypeScript (strict mode) + App Router
- **Database**: Supabase PostgreSQL
- **ORM**: Prisma
- **Auth**: Better Auth (Google, GitHub, Microsoft OAuth + Email OTP)
- **UI**: Tailwind CSS + Shadcn/ui + Lucide React icons
- **State Management**: 
  - Zustand pour Ã©tat global (user settings, UI state, draft invoices)
  - TanStack Query pour server state (data fetching, cache, mutations)
- **Forms**: React Hook Form + Zod resolver
- **Validation**: Zod (client + server)
- **Dates**: date-fns
- **PDF**: @react-pdf/renderer (prÃ©fÃ©rÃ©) ou jsPDF
- **Payments**: 
  - Stripe (CB, Apple Pay, Google Pay)
  - PayPal
  - GoCardless (SEPA Direct Debit)
- **Emails**: Resend ou Brevo
- **Toast notifications**: Sonner

## Architecture Principles

### Component Strategy
1. **Server Components by default** - Client Components only when:
   - Using React hooks (useState, useEffect, useCallback, useMemo)
   - Event handlers (onClick, onChange, onSubmit)
   - TanStack Query hooks
   - Browser APIs
2. **Server Actions** for all mutations (create, update, delete)
3. **File naming**: kebab-case (`invoice-form.tsx`, `client-list.tsx`)
4. **Component naming**: PascalCase (`InvoiceForm`, `ClientList`)

### Data Fetching & State
- **TanStack Query** for client-side data fetching
  - Query keys format: `['entity', { filters }]` (e.g., `['invoices', { status: 'PAID' }]`)
  - Always invalidate cache after mutations
  - Configure `staleTime` and `cacheTime` appropriately
- **Zustand** for global state
  - One store per domain: `useUserStore`, `useInvoiceStore`, `useUIStore`
  - Use selectors to avoid re-renders
  - Persist important data with `persist` middleware

### Code Quality
- **TypeScript**: NEVER use `any` - use `unknown` if needed
- **Performance**: 
  - ALWAYS use `useCallback` for functions passed as props
  - ALWAYS use `useMemo` for expensive computations or filtered lists
  - Lazy load heavy components with `dynamic()`
  - Debounce search inputs (300ms minimum)
- **Error Handling**: 
  - Always use try/catch in Server Actions
  - Return structured responses: `{ success: boolean, data?, error? }`
  - Display user-friendly error messages with toasts
- **Validation**: 
  - ALWAYS validate with Zod on server-side
  - Optionally validate on client for UX

## Coding Standards

### Server Actions Pattern
```typescript
'use server'

import { z } from 'zod'
import { prisma } from '@/lib/prisma'
import { revalidatePath } from 'next/cache'

const schema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
})

export async function createClient(formData: FormData) {
  const session = await getSession()
  if (!session) return { success: false, error: 'Unauthorized' }

  try {
    const data = schema.parse(Object.fromEntries(formData))
    
    const client = await prisma.client.create({
      data: {
        ...data,
        userId: session.user.id,
      }
    })
    
    revalidatePath('/dashboard/clients')
    return { success: true, data: client }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, error: 'Validation failed', details: error.errors }
    }
    return { success: false, error: 'Failed to create client' }
  }
}
```

### TanStack Query Pattern
```typescript
'use client'

// Query
const { data: invoices, isLoading } = useQuery({
  queryKey: ['invoices', { status: 'PAID' }],
  queryFn: () => getInvoices({ status: 'PAID' }),
  staleTime: 5 * 60 * 1000, // 5 min
})

// Mutation
const mutation = useMutation({
  mutationFn: createInvoice,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['invoices'] })
    toast.success('Facture crÃ©Ã©e !')
  },
  onError: (error) => {
    toast.error('Erreur lors de la crÃ©ation')
  }
})
```

### Zustand Store Pattern
```typescript
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface InvoiceStore {
  draftInvoice: Invoice | null
  setDraftInvoice: (invoice: Invoice | null) => void
}

export const useInvoiceStore = create<InvoiceStore>()(
  persist(
    (set) => ({
      draftInvoice: null,
      setDraftInvoice: (invoice) => set({ draftInvoice: invoice }),
    }),
    { name: 'invoice-storage' }
  )
)

// Usage with selector to avoid re-renders
const draftInvoice = useInvoiceStore((state) => state.draftInvoice)
```

## Project Structure
```
facturflow/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ (auth)/                 # Public routes
â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â””â”€â”€ signup/
â”‚   â”œâ”€â”€ (dashboard)/            # Protected routes
â”‚   â”‚   â”œâ”€â”€ layout.tsx          # Dashboard layout with sidebar
â”‚   â”‚   â”œâ”€â”€ page.tsx            # Dashboard home
â”‚   â”‚   â”œâ”€â”€ clients/
â”‚   â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â”œâ”€â”€ invoices/
â”‚   â”‚   â”œâ”€â”€ quotes/
â”‚   â”‚   â””â”€â”€ settings/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ auth/[...all]/      # Better Auth routes
â”‚   â”‚   â””â”€â”€ webhooks/           # Stripe, PayPal, GoCardless webhooks
â”‚   â””â”€â”€ layout.tsx              # Root layout
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                     # Shadcn components
â”‚   â”œâ”€â”€ forms/                  # Reusable forms
â”‚   â”‚   â”œâ”€â”€ invoice-form.tsx
â”‚   â”‚   â”œâ”€â”€ client-form.tsx
â”‚   â”‚   â””â”€â”€ product-form.tsx
â”‚   â””â”€â”€ layouts/
â”‚       â””â”€â”€ dashboard-layout.tsx
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ auth.ts                 # Better Auth config
â”‚   â”œâ”€â”€ auth-client.ts          # Better Auth client for React
â”‚   â”œâ”€â”€ prisma.ts               # Prisma singleton
â”‚   â”œâ”€â”€ validations/            # Zod schemas
â”‚   â”‚   â”œâ”€â”€ client.ts
â”‚   â”‚   â”œâ”€â”€ invoice.ts
â”‚   â”‚   â””â”€â”€ product.ts
â”‚   â””â”€â”€ utils.ts                # Utility functions
â”œâ”€â”€ hooks/                      # Custom hooks
â”‚   â”œâ”€â”€ use-clients.ts
â”‚   â”œâ”€â”€ use-invoices.ts
â”‚   â””â”€â”€ use-products.ts
â”œâ”€â”€ stores/                     # Zustand stores
â”‚   â”œâ”€â”€ use-user-store.ts
â”‚   â”œâ”€â”€ use-invoice-store.ts
â”‚   â””â”€â”€ use-ui-store.ts
â”œâ”€â”€ types/                      # TypeScript types
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ prisma/
â”‚   â””â”€â”€ schema.prisma
â”œâ”€â”€ .claude.md                  # This file
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ copilot-instructions.md # Full detailed docs
â””â”€â”€ README.md
```

## Database Schema (Prisma)

### Key Models

**User**
- Company info (name, SIRET, SIREN, VAT, address, logo)
- Business type (WEB_DEV, DESIGN, CONSULTING, etc.)
- Invoice settings (prefixes, next numbers)
- Payment providers (GoCardless tokens, Stripe ID)
- Relations: clients[], products[], documents[]

**Client**
- Type: COMPANY (B2B with SIRET) or INDIVIDUAL (B2C)
- Contact info (email, phone, address)
- SEPA mandate info (GoCardless mandate ID, status)
- Stats: totalInvoiced, totalPaid
- Relations: documents[]

**Product**
- Name, description, type (SERVICE/PRODUCT)
- Pricing: unitPrice, unit, vatRate
- Optional stock tracking
- Relations: lineItems[]

**Document**
- Type: INVOICE, QUOTE, CREDIT_NOTE, PURCHASE_ORDER, DELIVERY_NOTE, RECEIPT, PROFORMA, CONTRACT
- Client reference
- Dates: date, dueDate, validUntil
- Status: DRAFT, SENT, VIEWED, ACCEPTED, PAID, OVERDUE, etc.
- Amounts: subtotal, taxTotal, total, discount, paidAmount
- Payment: paymentMethod, paidAt
- Relations: lineItems[], payments[], reminders[]

**DocumentLineItem**
- Product reference (optional)
- Description, quantity, unitPrice, vatRate
- Calculated totals: subtotal, taxAmount, total
- Order for sorting
- CASCADE delete with document

**RecurringInvoice**
- Client reference
- Frequency: WEEKLY, MONTHLY, QUARTERLY, YEARLY
- Schedule: startDate, endDate, nextDate
- Template data (JSON)
- Status: active/inactive

**Payment**
- Document reference
- Provider: GOCARDLESS, STRIPE, PAYPAL, BANK_TRANSFER
- GoCardless specific: paymentId, status
- Amount, currency, timestamps

## Key Features

### 1. Multi-Document Types
- Factures (invoices)
- Devis (quotes)
- Avoirs (credit notes)
- Bons de commande (purchase orders)
- Bons de livraison (delivery notes)
- ReÃ§us (receipts)
- Factures proforma
- Contrats (contracts) - post-MVP

### 2. SEPA Direct Debit (GoCardless) - KILLER FEATURE

**Setup Flow:**
```
1. User â†’ Settings â†’ Connect GoCardless (OAuth)
2. Create/connect GoCardless account
3. Authorize FacturFlow
4. Store access_token in DB
5. Badge "SEPA activÃ©" in dashboard
```

**Invoice with SEPA Flow:**
```
1. Create invoice â†’ Select "SEPA" payment method
2. Send to client
3. Client clicks link â†’ GoCardless mandate page
4. Client enters IBAN + signs mandate
5. Mandate pending (3-5 days bank activation)
6. Webhook: mandate.active â†’ Client ready
7. On due date: automatic payment created
8. Webhook: payment.confirmed â†’ Invoice marked PAID
```

**Recurring + SEPA Flow:**
```
1. Create recurring invoice + SEPA
2. First invoice â†’ mandate setup (once)
3. Monthly: auto-generate invoice + auto-payment
4. Zero manual intervention
```

### 3. Payments Integration

**Stripe** (CB, Apple Pay, Google Pay):
- Connect Stripe via OAuth
- Generate payment links in invoices
- Webhooks: payment.succeeded â†’ Invoice PAID
- Fees: ~1.5% + 0.25â‚¬

**PayPal**:
- Connect PayPal Business account
- Generate PayPal payment buttons
- Webhooks: PAYMENT.CAPTURE.COMPLETED â†’ Invoice PAID
- Fees: ~2.5-3.5%

**GoCardless** (SEPA):
- OAuth connection
- Mandate management
- Automatic payments
- Fees: 1% + 0.20â‚¬

### 4. Templates MÃ©tiers
9 templates adaptÃ©s par mÃ©tier:
- Web Developer
- Designer / Graphiste
- Consultant
- Artisan / BTP
- Photographe
- RÃ©dacteur
- Coach / Formateur
- E-commerce
- Services gÃ©nÃ©riques

### 5. Recurring Invoices
- Weekly, monthly, quarterly, yearly
- Auto-generation on schedule
- Auto-payment with SEPA
- Email notifications

### 6. Automatic Reminders
3 levels:
- FRIENDLY (soft reminder)
- FIRM (stronger tone)
- FORMAL (official notice)

Scheduled based on due date.

### 7. Annual Reports & Admin Docs
- CA total, TVA collectÃ©e
- Charges dÃ©ductibles
- Export pour URSSAF
- Export comptable (FEC, CSV)
- Attestations diverses

### 8. E-invoicing (Ã€ venir)
- Obligatory Sept 2026 for businesses
- Obligatory Sept 2027 for freelances
- Business plan: includes Chorus Pro compliance
- Pro plan: update in June 2027

## Pricing (Validated)

### Free
- 14 days Pro trial
- Then: 10 documents/month, 5 clients, 1 user
- Basic PDF, manual payment only

### Pro - 14â‚¬/month
- Unlimited documents/clients
- SEPA Direct Debit (GoCardless) ğŸ”¥
- Recurring invoices
- Automatic reminders
- 9 business templates
- CB & PayPal payments
- Annual reports & URSSAF docs

### Business - 29â‚¬/month
- All Pro features
- Multi-users (3 accounts)
- API & Webhooks
- E-invoicing (Sept 2026)
- Priority support
- Advanced exports

## Important Workflows

### Creating an Invoice
```
1. Dashboard â†’ New Invoice
2. Select client (or create quick)
3. Add line items:
   - Select existing product (auto-fill price/VAT) OR
   - Custom line (manual description/price)
4. Auto-calculations:
   - Subtotal = sum(quantity Ã— unitPrice)
   - VAT = sum(subtotal Ã— vatRate)
   - Total = subtotal + VAT
5. Choose payment method:
   - Bank transfer
   - Credit card (Stripe)
   - PayPal
   - SEPA Direct Debit
6. PDF preview
7. Save as draft OR Send
8. Auto-generate invoice number (prefix + year + counter)
9. Email to client (optional)
```

### PDF Generation
```
1. Select template (default or custom)
2. Inject invoice + user + client data
3. Verify calculations server-side
4. Generate PDF with @react-pdf/renderer
5. Upload to Supabase Storage OR generate on-the-fly
6. Store URL in document.pdfUrl
```

### Financial Calculations
- ALWAYS use Decimal or store as cents (integer)
- Round to 2 decimals for display
- Verify calculations server-side before save
- Use formatCurrency() helper for display

### Document Numbering
- Atomic increment (Prisma transaction)
- Format: `{prefix}-{year}-{number}` (e.g., `INV-2025-0001`)
- Separate sequence per document type
- No gaps allowed

## Security Rules

### Data Protection
- Validate ALWAYS server-side (Zod)
- Verify ownership (user can only access their data)
- Sanitize user inputs
- Rate limiting on sensitive API routes
- Never store passwords in plain text
- Never expose API keys client-side

### Financial Data
- Never log sensitive data (IBANs, card numbers)
- Use HTTPS only
- PCI-DSS compliance via Stripe/PayPal
- SEPA mandates stored by GoCardless only
- Encrypt sensitive fields in DB

### Access Control
- Middleware protects /dashboard/* routes
- Server Actions check session
- API routes verify authentication
- Multi-user: role-based permissions (Business plan)

## Performance Optimization

- Pagination: 20 items/page
- Infinite scroll on mobile
- Virtual scrolling if >100 items
- DB indexes on: userId, clientId, status, date
- Lazy load PDF viewer with dynamic()
- Debounce search inputs (300ms)
- Optimize images (Next.js Image component)

## Never Do

âŒ Never use `any` type
âŒ Never skip server-side validation
âŒ Never store sensitive data in localStorage
âŒ Never reproduce copyrighted content
âŒ Never use browser storage APIs
âŒ Never expose API keys
âŒ Never trust client-side data
âŒ Never skip error handling

## Always Do

âœ… Use Shadcn/ui components
âœ… Validate with Zod on server
âœ… Use Server Actions for mutations
âœ… Use TanStack Query for fetching
âœ… Add proper TypeScript types
âœ… Handle errors with try/catch
âœ… Use ARIA labels for accessibility
âœ… Test payment flows in sandbox first
âœ… Use loading.tsx and error.tsx for routes
âœ… Revalidate paths after mutations

## Testing Strategy

### Payment Providers Sandbox

**Stripe Test Cards:**
- Success: 4242 4242 4242 4242
- Declined: 4000 0000 0000 0002
- 3D Secure: 4000 0027 6000 3184

**GoCardless Test IBANs:**
- Success: GB33BUKB20201555555555
- Insufficient funds: GB60BARC20000055779911
- Account closed: GB89NWBK60161331926819

**Webhooks Testing:**
- Use ngrok for local webhook testing
- Stripe CLI for event simulation
- GoCardless sandbox environment

## Common Patterns

### Loading States
```typescript
if (isLoading) return <Skeleton />
if (error) return <ErrorMessage error={error} />
if (!data) return null
```

### Form Handling
```typescript
const form = useForm({
  resolver: zodResolver(schema),
  defaultValues: initialData
})

async function onSubmit(data) {
  const result = await createInvoice(data)
  if (result.success) {
    toast.success('Facture crÃ©Ã©e !')
    router.push('/dashboard/invoices')
  } else {
    toast.error(result.error)
  }
}
```

### Optimistic Updates
```typescript
const mutation = useMutation({
  mutationFn: updateInvoice,
  onMutate: async (newData) => {
    await queryClient.cancelQueries({ queryKey: ['invoices', id] })
    const previous = queryClient.getQueryData(['invoices', id])
    queryClient.setQueryData(['invoices', id], newData)
    return { previous }
  },
  onError: (err, variables, context) => {
    queryClient.setQueryData(['invoices', id], context.previous)
  },
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: ['invoices', id] })
  }
})
```

## Reference

Full detailed documentation in `.github/copilot-instructions.md`

For GoCardless API: https://developer.gocardless.com
For Stripe API: https://stripe.com/docs/api
For Better Auth: https://www.better-auth.com/docs
For Prisma: https://www.prisma.io/docs
For Shadcn/ui: https://ui.shadcn.com
For TanStack Query: https://tanstack.com/query/latest